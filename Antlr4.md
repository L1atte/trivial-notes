# AST

- ## Lexical analysis aka Tokennization

  这个过程，你的代码会被转译为一系列标记的集合。这些标记不关心它们的组合关系，纯粹是代码的组成部分。你可以把它想象成一个不同类型标记的列表或数组

#  Antlr4

![compiler](/Users/latte/Documents/image/compiler.png)

查看图表我们发现，为了为我们的语言创建编译器，我们需要：

- 为该语言提出一个***\*上下文无关的语法\****
- 针对给定的源代码运行具有该语法的词法***\*分析器\****以生成一组***\*标记\****
- 将这些***\*标记\****输入***\*解析器\****以生成***\*抽象语法树 (AST)\****
- 让我们的***\*语义分析器\****检查 AST 以确保它在***\*语义上是有效的\****
- ***\*可选地通过优化器\****提供 AST以***\*裁剪掉不必要的代码\****
- 最后从该 AST 生成***\*可执行代码\****并将其作为输出返回



ANTLR 最让我着迷的是，因为它可以针对 JavaScript 运行时，我们可以在前端使用相同的语法来解析传入的源代码，将其转换为一组标记，在语法和语义上验证代码，并且将所有内容与 Microsoft 的[Monaco Editor](https://microsoft.github.io/monaco-editor/)等解决方案集成，以在我们的网页上创建**内置代码编辑器**，完全支持**语法突出显示**和我们自定义语言的**代码验证。**